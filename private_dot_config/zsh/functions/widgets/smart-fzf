# Smart fzf widget that adapts based on command line context
# Bound to Ctrl+T - provides file selection, directory navigation, history, process kill, etc.

emulate -L zsh
setopt localoptions pipefail no_aliases 2> /dev/null

local -a tokens
local cmd prefix mode resolved_cmd

# Parse current buffer into tokens
tokens=(${(z)LBUFFER})

# Determine the command (first token)
cmd="${tokens[1]:-}"

# Get the current word (last token or empty)
# Only treat it as a prefix if the buffer doesn't end with whitespace
if [[ "$LBUFFER" =~ [[:space:]]$ ]]; then
  prefix=""
else
  prefix="${tokens[-1]:-}"
fi

# Cache command availability
local has_fd=false
command -v fd &>/dev/null && has_fd=true

# ============================================================================
# Helper Functions
# ============================================================================

# Resolve alias to actual command
_resolve_alias() {
  local cmd="$1"
  local expansion
  
  if ! alias "$cmd" &>/dev/null; then
    echo "$cmd"
    return
  fi
  
  expansion="${aliases[$cmd]}"
  echo "${${(z)expansion}[1]}"
}

# Unified fzf picker with consistent options
_fzf_picker() {
  local prompt="$1"
  local size="${2:-80%,60%}"
  local multi="${3:-false}"
  shift 3
  
  if [[ "$multi" == "true" ]]; then
    fzf-tmux -p "$size" --ghost "$prompt" -m "$@" | paste -sd " " -
  else
    fzf-tmux -p "$size" --ghost "$prompt" "$@"
  fi
}

# List files/directories with fd or find fallback
_list_files() {
  local type="$1"
  
  if $has_fd; then
    case "$type" in
      dir)
        fd --type d --hidden --exclude .git --exclude node_modules
        ;;
      file)
        fd --hidden --exclude .git --exclude node_modules
        ;;
      text)
        fd --type f \
          --exclude '*.{png,jpg,jpeg,gif,bmp,ico,svg,webp}' \
          --exclude '*.{mp3,mp4,avi,mkv,mov,flv,wav,ogg}' \
          --exclude '*.{zip,tar,gz,bz2,xz,7z,rar}' \
          --exclude '*.{pdf,doc,docx,xls,xlsx,ppt,pptx}' \
          --exclude '*.{exe,dll,so,dylib,a,o}' \
          --exclude '.git' --exclude 'node_modules' --hidden
        ;;
    esac
  else
    case "$type" in
      dir)
        find . -type d ! -path '*/\.git/*' ! -path '*/node_modules/*' 2>/dev/null | sed 's|^\./||'
        ;;
      file)
        find . ! -path '*/\.git/*' ! -path '*/node_modules/*' 2>/dev/null | sed 's|^\./||'
        ;;
      text)
        find . -type f \
          ! -path '*/\.git/*' ! -path '*/node_modules/*' \
          ! -name '*.png' ! -name '*.jpg' ! -name '*.jpeg' ! -name '*.gif' \
          ! -name '*.mp3' ! -name '*.mp4' ! -name '*.zip' ! -name '*.tar' \
          ! -name '*.pdf' ! -name '*.exe' ! -name '*.so' ! -name '*.dylib' \
          2>/dev/null | sed 's|^\./||'
        ;;
    esac
  fi
}

# Insert result into buffer with optional quoting
_insert_result() {
  local selected="$1"
  local quote_mode="${2:-none}"  # none, single, multi, replace
  
  if [[ -z "$selected" ]]; then
    zle reset-prompt
    return
  fi
  
  # Remove prefix if it exists and is a partial word
  if [[ -n "$prefix" && "$quote_mode" != "replace" ]]; then
    LBUFFER="${LBUFFER:0:-${#prefix}}"
  fi
  
  case "$quote_mode" in
    single)
      LBUFFER="${LBUFFER}${(q)selected}"
      ;;
    multi)
      # Quote each line separately (for multi-select from fzf)
      local quoted=""
      local file
      for file in ${(f)selected}; do
        quoted+="${(q)file} "
      done
      LBUFFER="${LBUFFER}${quoted% }"
      ;;
    replace)
      # Replace entire buffer (for history mode)
      LBUFFER="$selected"
      ;;
    *)
      LBUFFER="${LBUFFER}${selected}"
      ;;
  esac
  
  zle reset-prompt
}

# Determine mode based on context
_determine_mode() {
  local cmd="$1"
  local resolved="$2"
  local subcommand="${tokens[2]:-}"
  
  # Direct command matches (highest priority)
  case "$cmd" in
    cd|pushd|rmdir|mkdir) echo "dir"; return ;;
    kill|pkill|killall) echo "process"; return ;;
    ssh|scp|sftp|telnet|ping|host|dig|nslookup) echo "host"; return ;;
    export|printenv) echo "env"; return ;;
    unset) echo "unset"; return ;;
    unalias) echo "alias"; return ;;
    ga) echo "git-add"; return ;;
  esac
  
  # Git subcommand detection
  if [[ "$cmd" == "git" || "$resolved" == "git" ]]; then
    case "$subcommand" in
      checkout|co|switch|branch|merge|rebase|diff|log|show)
        echo "git-branch"; return ;;
      add)
        echo "git-add"; return ;;
    esac
    
    # Check if alias expands to git add (with word boundaries)
    if [[ "$cmd" != "git" ]] && alias "$cmd" 2>/dev/null | grep -qE 'git\s+add(\s|$|;)'; then
      echo "git-add"; return
    fi
    
    echo "file"; return
  fi
  
  # Editor detection (check both cmd and resolved)
  case "$cmd" in
    nvim|vim|vi|emacs|nano|code|subl|atom|hx|helix|e)
      echo "text-file"; return ;;
  esac
  
  case "$resolved" in
    nvim|vim|vi|emacs|nano|code|subl|atom|hx|helix)
      echo "text-file"; return ;;
  esac
  
  # Default behavior
  if [[ -z "$LBUFFER" || "$LBUFFER" =~ ^[[:space:]]*$ ]]; then
    echo "history"
  else
    echo "file"
  fi
}

resolved_cmd=$(_resolve_alias "$cmd")
mode=$(_determine_mode "$cmd" "$resolved_cmd")

# ============================================================================
# Mode Functions
# ============================================================================

_mode_dir() {
  local result
  result=$(_list_files dir | _fzf_picker "Directories")
  _insert_result "$result" "single"
}

_mode_file() {
  local result
  result=$(_list_files file | _fzf_picker "Files" "80%,60%" true)
  _insert_result "$result"
}

_mode_process() {
  local result
  result=$(ps -eo user,pid,ppid,%cpu,%mem,stat,start,time,command 2>/dev/null | \
    _fzf_picker "Processes" "80%,60%" true --header-lines=1 --preview-window=hidden | \
    awk '{print $2}')
  _insert_result "$result"
}

_mode_host() {
  local result
  result=$(
    {
      setopt localoptions nonomatch nullglob
      local config_files
      config_files=(~/.ssh/config ~/.ssh/config.d/*(N))
      [[ ${#config_files} -gt 0 ]] && \
        awk '/^Host / {for(i=2;i<=NF;i++) if($i!~"*") print $i}' "${config_files[@]}" 2>/dev/null
      [[ -f ~/.ssh/known_hosts ]] && \
        awk -F'[, ]' '{print $1}' ~/.ssh/known_hosts 2>/dev/null | \
        sed 's/\[//g;s/\].*//g;s/:.*//g'
      [[ -f /etc/hosts ]] && \
        awk '{for(i=2;i<=NF;i++) if($i!="localhost") print $i}' /etc/hosts 2>/dev/null
    } | sort -u | _fzf_picker "Hosts" "50%,40%"
  )
  _insert_result "$result"
}

_mode_env() {
  local result
  result=$(printenv | cut -d= -f1 | sort | _fzf_picker "Env" "50%,40%" true)
  _insert_result "$result"
}

_mode_unset() {
  local result
  result=$(printenv | cut -d= -f1 | sort | _fzf_picker "Unset" "50%,40%" true)
  _insert_result "$result"
}

_mode_alias() {
  local result
  result=$(alias | sed 's/=.*//' | _fzf_picker "Alias" "50%,40%")
  _insert_result "$result"
}

_mode_git_branch() {
  local result
  result=$(git branch -a 2>/dev/null | \
    sed 's/^[* ]*//' | \
    sed 's#^remotes/##' | \
    sort -u | \
    _fzf_picker "Branch" "50%,40%")
  _insert_result "$result"
}

_mode_git_add() {
  local result
  result=$(git status --short 2>/dev/null | \
    awk '{print $2}' | \
    _fzf_picker "Git Add" "80%,60%" true \
      --preview 'git diff --color=always {} 2>/dev/null || git diff --color=always --cached {} 2>/dev/null || bat --color=always {}')
  _insert_result "$result"
}

_mode_text_file() {
  local result files
  result=$(_list_files text | \
    _fzf_picker "Files" "80%,60%" false -m \
      --preview 'bat --color=always --style=numbers --line-range=:500 {} 2>/dev/null || cat {}')
  
  # Quote each file individually for proper escaping with spaces
  if [[ -n "$result" ]]; then
    local quoted=""
    local file
    for file in ${(f)result}; do
      quoted+="${(q)file} "
    done
    _insert_result "${quoted% }"
  fi
}

_mode_history() {
  local result
  result=$(fc -rl 1 | \
    awk '{cmd=$0; sub(/^[ \t]*[0-9]+\**[ \t]+/, "", cmd); if (!seen[cmd]++) print $0}' | \
    _fzf_picker "History" "80%,60%" false --scheme=history --tac --query="$LBUFFER" | \
    sed 's/^[ \t]*[0-9]*\**[ \t]*//')
  _insert_result "$result" "replace"
}

# ============================================================================
# Execute Mode
# ============================================================================

case "$mode" in
  dir) _mode_dir ;;
  file) _mode_file ;;
  process) _mode_process ;;
  host) _mode_host ;;
  env) _mode_env ;;
  unset) _mode_unset ;;
  alias) _mode_alias ;;
  git-branch) _mode_git_branch ;;
  git-add) _mode_git_add ;;
  text-file) _mode_text_file ;;
  history) _mode_history ;;
esac

# vim: ft=zsh
